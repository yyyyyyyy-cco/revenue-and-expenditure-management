# 后端开发答辩准备指南

本手册旨在协助后端开发者理解系统架构、核心功能，并应对答辩中的常见技术提问。

---

## 🛠️ 后端技术栈与架构

### 核心技术选型
*   **Node.js (Express)**: 作为后端运行环境，采用事件驱动、非阻塞 I/O 模型，适合处理高并发请求。
*   **SQLite**: 嵌入式关系型数据库，无需配置独立的数据库服务器，具有便携性和高性能（ACID 事务支持）。
*   **JWT (JSON Web Token)**: 实现跨域身份验证，保证前后端分离架构下的无状态通信。
*   **bcryptjs**: 业界标准的加盐哈希加密，保障用户凭证安全。

---

## 📋 核心功能模块梳理

### 1. 用户认证与权限管理
*   **加密存储**: 注册时对原始密码进行哈希加密，数据库不存储明文。
*   **身份隔离**: 通过 `authMiddleware` 拦截请求，解析 Token 获取 `user_id`，并将其绑定到 `req` 对象。
*   **数据隔离**: 所有业务接口（账单、统计、分类）在 SQL 查询中均强制携带 `user_id` 过滤条件。

### 2. 账单管理系统
*   **动态筛选**: 支持按月份（YYYY-MM）、收支类型（收入/支出）、分类等多维度组合查询。
*   **分页加载**: 使用 `LIMIT` 和 `OFFSET` 机制，确保在大量数据下前端加载依然流畅。
*   **自动归类**: 自研分类判断引擎。创建账单时若未选分类，系统根据收支类型自动分配“其他收入”或“其他支出”分类 ID。

### 3. 多平台账单导入（技术难点/亮点）
*   **文件解析**: 兼容支付宝 (CSV) 的 GBK 编码与微信 (XLSX) 格式。
*   **智能对齐**: 针对第三方平台分类不统一的问题，核心算法通过关键词正则（如 `正则匹配：/餐饮|麦当劳/ -> 餐饮分类`）和映射表实现自动对齐。
*   **去重保障**: 在插入循环中使用 `WHERE NOT EXISTS` 子句进行原子化校验，防止同一流水被重复计入。

### 4. 周期性账单自动化
*   **任务追溯**: 系统具有“停机补偿”逻辑。若规则过期，下次运行时会递归补全所有缺失日期的账单。
*   **事务处理**: 账单生成与规则日期更新绑定在同一个 SQL 事务中，确保数据一致性。

### 5. 财务统计看板
*   **聚合分析**: 深度使用 SQL 的 `SUM`、`COUNT` 等聚合函数配合日期格式化函数 `strftime` 进行数据分析。
*   **多维展示**: 提供月度结余汇总、六个月收支趋势（折线图数据）、消费占比（饼图数据）。

---

## ❓ 答辩 Q&A (10个高频问题)

### Q1：你的系统是如何保证用户密码安全的？
**解答**：系统拒绝明文存储密码。我们使用了 `bcryptjs` 库，在存储前对密码进行加盐哈希（Salting & Hashing）自适应加密。即使数据库文件被泄露，攻击者也无法通过彩虹表逆向破解原始密码。此外，登录状态由 JWT 令牌维护，设置了有效期限制。

### Q2：在导入支付宝或微信账单时，系统如何处理分类？
**解答**：系统内置了一个智能归类引擎：
1. **静态映射**：针对支付宝相对标准的 “交易分类” 字段，建立映射表将外部标签转换为内部 ID。
2. **关键词匹配**：针对微信这种分类模糊的情况，系统会扫描“商品描述”和“对方名称”字段，利用正则（如 `/京东|天猫/`）自动识别为“日用百货”。
3. **兜底策略**：无法识别的账单统一归入“其他支出/收入”，确保数据完整。

### Q3：如何防止用户重复导入同一份账单文件导致数据错乱？
**解答**：我们在数据库插入层级实现了**幂等性校验**：插入语句中集成了 `WHERE NOT EXISTS` 条件，系统会实时比对“用户ID、金额、精确日期、流水类型及来源”这五个关键特征。如果已存在相同记录，插入操作会被静默跳过，有效防止数据冗余。

### Q4：为什么选择 SQLite 而不是 MySQL 或 MongoDB？
**解答**：
1. **轻量化**：本项目定位为个人理财工具，SQLite 文件数据库无需配置服务器环境，极大地降低了部署门槛。
2. **ACID 支持**：在批量导入等涉及多表写入的业务场景中，SQLite 的强事务支持能确保数据的绝对准确。
3. **性能够用**：对于个人用户即使有上万条记录，SQLite 的索引查询性能依然在毫秒量级。

### Q5：你的账单分页查询是怎么实现的？如果数据量达到百万级，性能如何优化？
**解答**：目前采用 `LIMIT` 和 `OFFSET` 的标准分页。针对目前的账单规模，由于我们在 `user_id` 和 `date` 上建立了索引，查询响应极快。若考虑到未来百万级性能，我会改用“寻找锚点”法（基于 ID 或日期过滤），通过上一次请求的最后一条 ID 进行 `WHERE id < :lastId` 过滤，避免数据库扫描不再需要的前导行。

### Q6：定期账单功能（如房租）是实时生成的吗？
**解答**：系统具有**自动补齐机制**。当用户触发相关页面加载时，后端会检索所有“下次执行时间 <= 今天”的任务。如果由于服务器停机导致任务漏记，系统会通过递归逻辑逐一补充每一笔过期账单，直到规则的 `next_date` 同步至未来时间。

### Q7：在统计功能中，你是如何从数据库里按月份提取趋势数据的？
**解答**：充分利用了 SQLite 强大的 `strftime` 函数。在 SQL 代码中直接对日期列进行格式化（如 `strftime('%Y-%m', date)`），并以此作为 `GROUP BY` 的依据进行聚合。这种方式将复杂的计算压力下沉到数据库，减轻了后端 Node.js 内存处理数据的负担。

### Q8：后端是如何确保用户只能查询到自己的账单？
**解答**：这是通过“强制外键过滤”实现的。前端所有 API 请求必须携带 Token，后端通过中间件从 Token 解析出 `userId`。在所有执行 CRUD 的 SQL 指令时，程序均强制拼接 `AND user_id = ?` 过滤。这在底层确保了无论请求参数如何变化，数据库扫描范围始终限制在用户本人的主权范围内。

### Q9：在批量导入账单时，如果中间某一行数据格式报错，会造成数据不一致吗？
**解答**：不会。我们引入了数据库**事务（Transaction）**机制。整个导入循环被包裹在 `BEGIN` 和 `COMMIT` 之间。如果在解析或写入过程中任意一步抛出异常，整个事务会立即执行 `ROLLBACK`，恢复到导入前的原始状态，确保数据库不会处于“导入了一半”的尴尬状态。

### Q10：如果有“多账本控制”新需求，后端结构需要如何演进？
**解答**：演进方案如下：
1. **表结构扩展**：新增 `account_books` 表（主键 ID, 用户 ID，账本名）。
2. **关系重构**：在 `bills` 和 `recurring_bills` 表中增加 `book_id` 字段作为外键。
3. **接口重构**：在所有查询接口中增加 `book_id` 入参，将过滤逻辑由 `WHERE user_id = ?` 升级为 `WHERE user_id = ? AND book_id = ?`。

---
祝答辩顺利！加油！
